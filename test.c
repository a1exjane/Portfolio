/*  1. Мы можем рассматривать цифры числа со второй по шестую т.к первая цифра числа по заданию равна
    значающему нулю
    2. Седьмая цифра не входит ни в одну из половин числа, соотвественно мы ей принебрегаем но учитываем
    что не значающее число может иметь 13 состояний. Значит конечный результат умножаем на 13 чтобы учесть
    этот факт
    3. Вторая часть числа с восьмой по тринадацатой цифры но учитывать стоит сумму ее цифр до максимальной
    суммы левой части числа
    4. Стоит отметить что нахождение количеств суммы цифр части числа можно сократить в два раза т.к вторая
    половина результата идентична первой (Стандартная комбинаторная фишка для экономии)
    5. Заметим что количество вариаций с помощью которой получается нужная сумма цифр в левой части является
    пентатопным (фигурным) числом которое к каждый 13 сумм отличается от стандартного тем, что вычитает
    из него пять помноженной на число из имеющихся множеств которая выше на 13 пунктов (5*dict_of_sums[i-13])
    6. Правая часть строится аналогично за тем исключением что в этом случае мы используем пятимерные
    гипертетраедальные числа
    7. Сведем задачу к задаче с урнами и шарами
    8. Сумма чисел - это количество шаров. Ящиков слева 5 а справа 6. Решаем эти задачи отдельно от друг -
    друга. Тогда способов размещения такого количества шаров в этих урнах равно число сочетаний из 5ти
    (для левой задачи) + по количество шаров - 1, по количеству шаров С(n+k-1,k).
    9. Но заметим что исходя из 13-значной системы счисления получиться так, что в одну ячейку нельзя будет
    положить больше 12 шаров. Соответственно с суммы больше 12ти мы должны вычитать количество сочетаний для
    суммы равной данной минус 12 С(n+k-12-1,k-12) умноженной на 5 (С из 5 по 1). Соответсвенно модифицировать
    нужно каждую 13-ую сумму и выше.
*/

#include <stdio.h>
#include <windows.h>

// Функция для вычисления факториалов
int factorial (int n)
{
    int F = 1;
    for(int i=1; i<=n; ++i)
	{
		F *= i;
	}
	return F;
}

// Функция вычисления количества сочетаний
int combination (int summa, int spots)
{
    int C = 1;
    for(int j = summa+1; j <= summa+spots-1; ++j)
    {
        C *= j;
    }
    C /= factorial(spots - 1);

    return (C);
}


int main (void)
{
    // Локаль
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    // Массив сумм где индекс равен сумме цифр числа
    int array_of_left_sums [61] = {0};
    int array_of_right_sums [73] = {0};

    // Массив сумм левой части числа
    for(int i = 0; i <= 30; i++)
    {
        if(i < 13)  // Так как 13-значная система счисления
        {
            array_of_left_sums[i] = combination(i, 5);
        }
        else if(i >= 13 && i < 26)
        {   // минус C(5,1) = 5
            array_of_left_sums[i] = combination(i, 5) - 5 * combination(i - 13, 5);
        }
        else
        {   // плюс C(5,2) = 10
            array_of_left_sums[i] = combination(i, 5) - 5 * combination(i - 13, 5) + 10 * combination(i - 26, 5);
        }
    }

    // Дублируем массив в обратную сторону, т.к. C(n, m) = C(n, n-m)
    for(int i = 31; i <= 60; i++)
    {
        array_of_left_sums[i] = array_of_left_sums[60 - i];
    }

    // Массив сумм правой части числа
    for(int i = 0; i <= 36; i++)
    {
        if(i < 13)  // Так как 13-значная система счисления
        {
            array_of_right_sums[i] = combination(i, 6);
        }
        else if(i >= 13 && i < 26)
        {
            array_of_right_sums[i] = combination(i, 6) - 6 * combination(i - 13, 6);
        }
        else
        {
            array_of_right_sums[i] = combination(i, 6) - 6 * combination(i - 13, 6) + 15 * combination(i - 26, 6);
        }

    }

    // Дублируем массив в обратную сторону, т.к. C(n, m) = C(n, n-m)
    for(int i = 37; i <= 72; i++)
    {
        array_of_right_sums[i] = array_of_right_sums[72 - i];
    }

    /*  // Расскоментить для вывода вариаций сумм цифр левой и правой части числа
    for(int i = 0; i <= 72; i++)
    {
        printf("%d: %d\n", i, array_of_right_sums[i]);
    }
    printf("\n");
    for(int i = 0; i <= 61; i++)
    {
        printf("%d: %d\n", i, array_of_left_sums[i]);
    }
    printf("\n");*/


    unsigned long long int num_of_digits = 0;  // Кол-во красивых чисел
    unsigned long int temp_impicant;  // Временная переменная для импликации
    for(int k = 0; k <=60; k++)
    {
        temp_impicant = array_of_right_sums[k];
        num_of_digits += array_of_left_sums[k] * temp_impicant;
    }

    num_of_digits *= 13;  // Для учета седьмой цифры

    printf("Количество красивых чисел: %llu\n", num_of_digits);

    return 0;
}




